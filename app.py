import numpy as np
import pickle
import streamlit as st
import pandas as pd
import datetime
import keras
import plotly.graph_objects as go

import base64


@st.cache(allow_output_mutation=True)
def get_base64_of_bin_file(bin_file):
    with open(bin_file, 'rb') as f:
        data = f.read()
    return base64.b64encode(data).decode()


def set_png_as_page_bg(png_file):
    bin_str = get_base64_of_bin_file(png_file)
    page_bg_img = '''
    <style>
    body {
    background-image: url("data:image/png;base64,%s");
    background-size:cover;


    }
    </style>
    ''' % bin_str

    st.markdown(page_bg_img, unsafe_allow_html=True)
    return



st.set_page_config(
page_title=" DEEP WIND ",
page_icon="ğŸš©",
#initial_sidebar_state="expanded",
)
old_models = keras.models.load_model('model.h5')



def home():
    return "welcome"


#@app.route('/predict', methods=['POST'])
def predict(temperature,pressure,wind_speed,wind_direction):
    values=np.array([[temperature,pressure,wind_speed,wind_direction]])
    prediction=old_models.predict(values.reshape(-1,1,4), batch_size=1)
    print(prediction)
    return prediction

def main():
    set_png_as_page_bg('000a.PNG')
    st.sidebar.header('User Input Parameters ğŸ’»ï¸')
    st.title(" DEEP WINDS âš’ï¸")
    st.write("Made by Quad Techies with â¤ï¸")
    st.write("WIND POWER PREDICTION DL WEB-APP ")
    
    
    temperature = st.sidebar.slider('Temperature â›…ğŸŒğŸŒ§ï¸ [Â°C]', -15, 1, 50)
    pressure = st.sidebar.slider('Pressure  âš¡ [atm]ï¸', 0.9, 1.0, 1.0)
    wind_speed = st.sidebar.slider('Wind Speed  ğŸŒ¬ï¸ [m/s]', 1, 1, 27)
    wind_direction = st.sidebar.slider('Wind Direction  ğŸš©ğŸŒ€ [deg]', 0, 1, 360)
    result = ""
    if st.button("Predict"):
        result = predict(temperature,pressure,wind_speed,wind_direction)
    st.success('Predicted Power is {} kW'.format(result))
    
    st.subheader("âš¡FORECASTINGâš¡")

# Setup file upload
    uploaded_file = st.file_uploader(label="Upload your CSV or Excel file. (200MB max)",type=['csv', 'xlsx'])

    global df
    if uploaded_file is not None:
       print(uploaded_file)
       print("hello")

       try:
          df = pd.read_csv(uploaded_file)
          st.write(df)
      
       except Exception as e:       
         df = pd.read_excel(uploaded_file)       
         st.write(df)
       st.write("---------------------------------------ğŸ“ˆ INPUT DATA ğŸ“ˆ ----------------------------------------")
       
       trace = go.Scatter(
    x = df['DateTime'],
    y = df['Power generated by system | (kW)'],
    mode = 'lines',
    name = 'Data'
)
       layout = go.Layout(
    title = "",
    xaxis = {'title' : "Date"},
    yaxis = {'title' : "Power generated by system | (kW)"}
)
       fig = go.Figure(data=[trace], layout=layout)
        #fig.show()
       st.write(fig)
        

       df1=df.reset_index()['Power generated by system | (kW)']
       import matplotlib.pyplot as plt
       st.write("\n")
       st.write("---------------------------ğŸ“ˆ INPUT DATA IN TERMS OF NO. OF HOURS ğŸ“ˆ --------------------------")
#        plt.xlabel('No. of hours')
# # Set the y axis label of the current axis.
#        plt.ylabel('Power generated by system | (kW)')
#        plt.plot(df1)
#        st.pyplot(plt)
       trace = go.Scatter(
    x = df1.index,
    y = df['Power generated by system | (kW)'],
    mode = 'lines',
    name = 'Data'
)
       layout = go.Layout(
    title = "",
    xaxis = {'title' : "No. of hours"},
    yaxis = {'title' : "Power generated by system (kW)"}
)
       fig = go.Figure(data=[trace], layout=layout)
        #fig.show()
       st.write(fig)
       from sklearn.preprocessing import MinMaxScaler
       scaler=MinMaxScaler(feature_range=(0,1))
       df1=scaler.fit_transform(np.array(df1).reshape(-1,1))
  ##splitting dataset into train and test split
       training_size=int(len(df1)*0.65)
       test_size=len(df1)-training_size
       train_data,test_data=df1[0:training_size,:],df1[training_size:len(df1),:1]
       import numpy
# convert an array of values into a dataset matrix
       import numpy
# convert an array of values into a dataset matrix
       def create_dataset(dataset, time_step=1):
	       dataX, dataY = [], []
	       for i in range(len(dataset)-time_step-1):
		       a = dataset[i:(i+time_step), 0]   ###i=0, 0,1,2,3-----99   100 
		       dataX.append(a)
		       dataY.append(dataset[i + time_step, 0])
	       return numpy.array(dataX), numpy.array(dataY)
# reshape into X=t,t+1,t+2,t+3 and Y=t+4
       time_step = 30
       X_train, y_train = create_dataset(train_data, time_step)
       X_test, ytest = create_dataset(test_data, time_step)
# reshape input to be [samples, time steps, features] which is required for LSTM
       X_train =X_train.reshape(X_train.shape[0],X_train.shape[1] , 1)
       X_test = X_test.reshape(X_test.shape[0],X_test.shape[1] , 1)
### Create the BILSTM model
       from tensorflow.keras.models import Sequential
       from tensorflow.keras.layers import Dense
       from tensorflow.keras.layers import LSTM
       from tensorflow.keras.layers import Bidirectional
       model = Sequential()
       model.add(Bidirectional(LSTM(350, input_shape=(1, 30))))
       model.add(Dense(1))
       model.compile(loss='mae', optimizer='adam')
       model.fit(X_train,y_train,validation_data=(X_test,ytest),epochs=10,batch_size=64,verbose=1)
       import tensorflow as tf
### Lets Do the prediction and check performance metrics
       train_predict=model.predict(X_train)
       test_predict=model.predict(X_test)
##Transformback to original form
       train_predict=scaler.inverse_transform(train_predict)
       test_predict=scaler.inverse_transform(test_predict)
### Calculate RMSE performance metrics
       import math
       from sklearn.metrics import mean_squared_error
       math.sqrt(mean_squared_error(y_train,train_predict))
### Test Data RMSEmath.sqrt(mean_squared_error(ytest,test_predict))
### Plotting 
 # shift train predictions for plotting
       look_back=30
       trainPredictPlot = numpy.empty_like(df1)
       trainPredictPlot[:, :] = np.nan
       trainPredictPlot[look_back:len(train_predict)+look_back, :] = train_predict
# shift test predictions for plotting
       testPredictPlot = numpy.empty_like(df1)
       testPredictPlot[:, :] = numpy.nan
       testPredictPlot[len(train_predict)+(look_back*2)+1:len(df1)-1, :] = test_predict
# plot baseline and predictions
       st.write("------------------------------------ğŸ“ˆ TRAIN AND TEST DATA ğŸ“ˆ --------------------------------------")
       #plt.plot(scaler.inverse_transform(df1))
       plt.plot(scaler.inverse_transform(df1), color="blue", linewidth=1, linestyle="-")
       plt.xlabel('No. of hours')
# Set the y axis label of the current axis.
       plt.ylabel('Power generated by system | (kW)')
       plt.plot(trainPredictPlot,label='Train Data',color="black",linewidth=2, linestyle="--")
       plt.plot(testPredictPlot,label='Test Data',color="orange",linewidth=2, linestyle="--")
       plt.legend(loc="upper left")
  #plt.show()
       st.pyplot(plt)
       x_input=test_data[len(test_data)-30:].reshape(1,-1)
       temp_input=list(x_input)
       temp_input=temp_input[0].tolist()
# demonstrate prediction for next 10 days
       from numpy import array
       lst_output=[]
       n_steps=30
       i=0
       while(i<24):
          if(len(temp_input)>30):
            #print(temp_input)
            x_input=np.array(temp_input[1:])
            print("{} HOUR input {}".format(i,x_input))
            x_input=x_input.reshape(1,-1)
            x_input = x_input.reshape((1, n_steps, 1))
        #print(x_input)
            yhat = model.predict(x_input, verbose=0)
            print("{} HOUR output {}".format(i,yhat))
            temp_input.extend(yhat[0].tolist())
            temp_input=temp_input[1:]
        #print(temp_input)
            lst_output.extend(yhat.tolist())
            i=i+1
          else:
            x_input = x_input.reshape((1, n_steps,1))
            yhat = model.predict(x_input, verbose=0)
            print(yhat[0])
            temp_input.extend(yhat[0].tolist())
            print(len(temp_input))
            lst_output.extend(yhat.tolist())
            i=i+1

       print(lst_output)
       day_new=np.arange(1,31)
       day_pred=np.arange(len(df1),len(df1)+24)
       import matplotlib.pyplot as plt
       print(len(df1))
  #plt.plot(day_new,scaler.inverse_transform(df1[len(df1)-30:]))
       st.write("-------------------------ğŸ“ˆ PREDICTED RESULTS FOR NEXT 24 HOURS ğŸ“ˆ--------------------------")
       
       plt.plot(day_pred,scaler.inverse_transform(lst_output),color="green",linewidth=1.5, linestyle="--",marker='*',markerfacecolor='yellow', markersize=7)
       plt.legend('GTTP',loc="upper left")
       
       plt.xlabel('No. of hours')
# Set the y axis label of the current axis.
       plt.ylabel('Power generated by system | (kW)')
       
       st.pyplot(plt)
       st.write("ğŸ·ï¸ G-Given Data, \nğŸ·ï¸T-Train Data, \nğŸ·ï¸T-Test Data, \nğŸ·ï¸P-Predicted Results")
  
#plt.show()
       st.write(scaler.inverse_transform(lst_output))
        


#@app.route('/')


if __name__ == "__main__":
    main()


